#
# plotter.py
#
"""Plot the solution that was generated by driver.py."""

# SciPy packages
import io
import logging  # , mpld3
from typing import Dict

import numpy as np
from matplotlib.pyplot import figure
from matplotlib import rc

# Fixes "UserWarning: Starting a Matplotlib GUI outside of the main thread will likely fail".
# https://stackoverflow.com/a/74471578/1147061
import matplotlib

matplotlib.use("agg")
# from arrhenius import plot_arrhenius

# Initialize logger:
# tell the program to send messages on its own behalf.
logger = logging.getLogger(__name__)

# our colour 'array'
# allows for more concise loop code
colour = [
    0,
    "b",
    "g",
    "r",
    "c",
    "m",
    "y",
    "k",
    "1",
    "0.75",
    "0.65",
    "0.55",
    "0.45",
    "0.35",
    "0.25",
    "0.25",
    "0.15",
]
if_SkipDrawingSpeciesWithZeroConcentrations = True


def fake_writer(plot):
    """this function tricks matplotlib into writing figure into memory instead of an actual file on disk."""
    buf = io.BytesIO()
    plot.savefig(buf, format="svg")
    buf.seek(0)
    data = buf.read()
    buf.close()
    return '<svg viewBox="0 0 2520 1584">' + data.decode("utf-8")[367:]


def sub_plots(
    job_id: str,
    plottingDict: Dict[str, int],
    true_data=None,
    user_data=None,
    newSize: int = 1000,
):
    """
    @param plottingDict: from species names to their locations in the data array.
    """
    logger = logging.getLogger(job_id).getChild("sub_plots")
    number_of_plots = len(plottingDict)
    logger.info("        (a) entered Plotter.sub_plots.")
    # create the figure and determine the 'layout' of the subplots.
    profiles = figure(
        figsize=(35, 22), dpi=80, facecolor="w", edgecolor="k", tight_layout=True
    )
    combined = figure(
        figsize=(35, 22), dpi=80, facecolor="w", edgecolor="k", tight_layout=True
    )
    # Arrange the subplots in a square grid. Figure out how many rows and columns we need.
    dimensions = int(np.ceil(np.sqrt(number_of_plots)))
    logger.info(
        f"        (b) Attempting to arrange {number_of_plots} plots over a {dimensions}x{dimensions} square grid:"
    )
    rc("font", size=22)
    sub_combined = combined.add_subplot(
        1, 1, 1, title="Combined True Profile", xlabel="time", ylabel="Concentration"
    )
    if user_data is not None:
        true_data = make_same_length(job_id, true_data, user_data)
        # now that the shapes of the two datasets are aligned, we can sample them
        user_data_sampled = user_data[:, :: user_data.shape[1] // newSize]
        # pre-cache x-datapoints for userDataSet
        data_x_user = user_data_sampled[0, :]
    true_data_sampled = true_data[:, :: true_data.shape[1] // newSize]
    data_x_true = true_data_sampled[0, :]
    logger.info(
        f"            Lossy-compressing true_data by selecting only {newSize} items, "
        f"which means a span of every {true_data.shape[1] / newSize} items.\n"
        f"            The true_data is compressed from {true_data.shape} to {true_data_sampled.shape}."
    )
    logger.info("            Drawing curves for:")
    # now for every species to be plotted:
    for subplot_id, (name, location) in enumerate(plottingDict.items(), start=1):
        logger.info(f"              {name}")
        sub_individual = profiles.add_subplot(
            dimensions,
            dimensions,
            subplot_id,
            title="Concentration Profile of " + name,
            xlabel="time",
            ylabel="[" + name + "]",
        )
        # first true model:
        data_y_this = true_data_sampled[location + 1, :]
        if not (
            if_SkipDrawingSpeciesWithZeroConcentrations
            and not any(y != 0 for y in data_y_this)
        ):
            sub_individual.plot(
                data_x_true,
                data_y_this,
                colour[1],
                label="True " + "[" + name + "]",
                linestyle="-",
            )
            sub_combined.plot(
                data_x_true,
                data_y_this,
                colour[subplot_id + 2],
                label="True " + "[" + name + "]",
                linestyle="-",
            )
        # then user model:
        if user_data is not None:
            data_y_this = user_data_sampled[location + 1, :]
            if not (
                if_SkipDrawingSpeciesWithZeroConcentrations
                and not any(y != 0 for y in data_y_this)
            ):
                sub_individual.plot(
                    data_x_user,
                    data_y_this,
                    colour[2],
                    label="User " + "[" + name + "]",
                    linestyle="--",
                )
                sub_combined.plot(
                    data_x_user,
                    data_y_this,
                    colour[subplot_id + 2],
                    label="User " + "[" + name + "]",
                    linestyle="--",
                )
        # sub_individual.legend()
    sub_combined.legend()
    logger.info("        (c) Saving SVG: [Individual]")
    # profiles.tight_layout()
    profiles = fake_writer(profiles)
    logger.info("                        [Combined]")
    combined = fake_writer(combined)
    logger.info("                        Done.")
    return profiles, combined


def make_same_length(
    job_id: str, true_data: np.ndarray, user_data: np.ndarray
) -> np.ndarray:
    """
    Align the shape of the trueDataSet to that of the userDataSet (by extending or truncating trueDataSet).
    """
    logger = logging.getLogger(job_id).getChild("make_same_length")
    if true_data.size == 0 or user_data.size == 0:
        logger.error("            One of the datasets is empty. Cannot align shapes.")
        return true_data
    logger.info(
        f"            Aligning shapes of userDataSet ({user_data.shape}) and trueDataSet ({true_data.shape})."
    )
    # if the trueDataSet is shorter, extend it to match the length of the userDataSet
    if true_data.shape[1] < user_data.shape[1]:
        length_difference = user_data.shape[1] - true_data.shape[1]
        logger.info(
            f"            The trueDataSet is shorter than the userDataSet, so we will extend it (by {length_difference} time steps) to match the length of the userDataSet."
        )
        final_concentrations = true_data[:, -1].reshape(-1, 1)
        patch = np.repeat(final_concentrations, length_difference, axis=1)
        true_data = np.append(
            true_data,
            patch,
            axis=1,
        )
        logger.info(f"            The trueDataSet is now {true_data.shape}.")
    elif true_data.shape[1] > user_data.shape[1]:
        logger.info(
            "            The trueDataSet is longer. Truncating it to match the length of the userDataSet."
        )
        true_data = true_data[:, : user_data.shape[1]]
    return true_data


if __name__ == "__main__":
    logger.info("Successfully loaded Plotter.py.")
