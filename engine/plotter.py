"""Plot the solution that was generated by driver.py."""

import io
import logging
from typing import Dict, Optional

import numpy as np
from matplotlib.pyplot import figure
from matplotlib import rc
from kernel.engine import align
import matplotlib.pyplot as plt
from matplotlib import cm

# Fixes "UserWarning: Starting a Matplotlib GUI outside of the main thread will likely fail".
# https://stackoverflow.com/a/74471578/1147061
import matplotlib

matplotlib.use("agg")


def fake_writer(fig):
    """this function tricks matplotlib into writing figure into memory instead of an actual file on disk."""
    buf = io.BytesIO()
    fig.savefig(buf, format="svg")
    buf.seek(0)
    data = buf.read()
    buf.close()
    return '<svg viewBox="0 0 2520 1584">' + data.decode("utf-8")[367:]


def sub_plots(
    job_id: str,
    plotting_dict: Dict[str, int],
    true_data: Optional[np.ndarray] = None,
    user_data: Optional[np.ndarray] = None,
    new_size: int = 1000,
    skip_drawing_species_with_zero_concentrations: bool = True,
):
    logger = logging.getLogger(job_id).getChild("sub_plots")
    number_of_plots = len(plotting_dict)
    logger.info("        (a) entered Plotter.sub_plots.")
    # Arrange the subplots in a square grid. Figure out how many rows and columns we need.
    dimensions = int(np.ceil(np.sqrt(number_of_plots)))
    logger.info(
        f"        (b) Attempting to arrange {number_of_plots} plots over a {dimensions}x{dimensions} square grid:"
    )
    plt.rc("font", size=22)
    fig_profiles, axes = plt.subplots(
        dimensions, dimensions, figsize=(35, 22), dpi=80, constrained_layout=True
    )
    axes = axes.flatten()
    fig_combined, ax_combined = plt.subplots(
        figsize=(35, 22), dpi=80, constrained_layout=True
    )
    ax_combined.set(
        title="Combined True Profile", xlabel="time", ylabel="Concentration"
    )
    data_x_user = None
    user_data_sampled = None
    if user_data is not None and true_data is not None:
        true_data = align.make_same_length(job_id, true_data, user_data)
        user_data_sampled = user_data[:, :: max(1, user_data.shape[1] // new_size)]
        data_x_user = user_data_sampled[0, :]
    if true_data is not None:
        true_data_sampled = true_data[:, :: max(1, true_data.shape[1] // new_size)]
        data_x_true = true_data_sampled[0, :]
    else:
        true_data_sampled = None
        data_x_true = None
    logger.info(
        f"            Lossy-compressing true_data by selecting only {new_size} items, "
        f"which means a span of every {true_data.shape[1] / new_size if true_data is not None else 'N/A'} items.\n"
        f"            The true_data is compressed from {true_data.shape if true_data is not None else 'N/A'} to {true_data_sampled.shape if true_data_sampled is not None else 'N/A'}."
    )
    logger.info("            Drawing curves for:")
    # Assign a unique color to each name using a colormap
    color_map = cm.get_cmap("tab20")
    name_list = list(plotting_dict.keys())
    num_colors = 20  # tab20 always has 20 distinct colors
    color_dict = {name: color_map(i % num_colors) for i, name in enumerate(name_list)}
    for subplot_id, (name, location) in enumerate(plotting_dict.items()):
        logger.info(f"              {name}")
        ax = axes[subplot_id]
        ax.set(
            title=f"Concentration Profile of {name}", xlabel="time", ylabel=f"[{name}]"
        )
        color = color_dict[name]
        y_true = (
            true_data_sampled[location + 1, :]
            if (true_data_sampled is not None and data_x_true is not None)
            else None
        )
        y_user = (
            user_data_sampled[location + 1, :]
            if (user_data_sampled is not None and data_x_user is not None)
            else None
        )
        # Only fill if both are available, not skipped, and shapes match
        if (
            y_true is not None
            and y_user is not None
            and data_x_true is not None
            and data_x_user is not None
            and y_true.shape == y_user.shape == data_x_true.shape == data_x_user.shape
            and not (
                skip_drawing_species_with_zero_concentrations
                and not any(y != 0 for y in y_true)
                and not any(y != 0 for y in y_user)
            )
        ):
            x_fill = np.array(data_x_true, dtype=float)
            y1_fill = np.array(y_true, dtype=float)
            y2_fill = np.array(y_user, dtype=float)
            ax.fill_between(x_fill, y1_fill, y2_fill, color=color, alpha=0.2)  # type: ignore
            ax_combined.fill_between(x_fill, y1_fill, y2_fill, color=color, alpha=0.2)  # type: ignore
        # Plot true line
        if y_true is not None and not (
            skip_drawing_species_with_zero_concentrations
            and not any(y != 0 for y in y_true)
        ):
            logger.info(
                f"                True model for {name} at location {location + 1}."
            )
            ax.plot(
                data_x_true,
                y_true,
                label=f"True [{name}]",
                linestyle="-",
                color=color,
            )
            ax_combined.plot(
                data_x_true,
                y_true,
                label=f"True [{name}]",
                linestyle="-",
                color=color,
            )
        # Plot user line
        if y_user is not None and not (
            skip_drawing_species_with_zero_concentrations
            and not any(y != 0 for y in y_user)
        ):
            logger.info(
                f"                User model for {name} at location {location + 1}."
            )
            ax.plot(
                data_x_user,
                y_user,
                label=f"Your [{name}]",
                linestyle="--",
                color=color,
            )
            ax_combined.plot(
                data_x_user,
                y_user,
                label=f"Your [{name}]",
                linestyle="--",
                color=color,
            )
        ax.legend()
    ax_combined.legend()
    logger.info("        (c) Saving SVG: [Individual]")
    profiles_svg = fake_writer(fig_profiles)
    logger.info("                        [Combined]")
    combined_svg = fake_writer(fig_combined)
    logger.info("                        Done.")
    plt.close(fig_profiles)
    plt.close(fig_combined)
    return profiles_svg, combined_svg
